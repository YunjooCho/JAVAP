package day0922;

public class Ex01MVC {
	/*
	 * 객체 지향의 5원칙 중
	 * 단일책임원칙(SRP)라는 원칙이 있다
	 * 이 원칙은 클래스가 단 하나의 책임을 지어야 한다고 말한다
	 * 하나의 책임이란, UI를 담당하는 클래스면 UI만 담당하고,
	 * 데이터 컨트롤을 담당하는 클래스면 데이터 컨트롤만 담당해야한다고 하는 것이다.
	 * UI란 사용자가 보는 프로그램 화면을 UI라고 한다(User Interface)
	 * 
	 * 하지만 지금까지 우리가 만들었던 클래스들은 이러한 단일책임원칙을 지키지 않았다.
	 * 우리가 지금까지 만들었던 클래스들은 Student나 Car 클래스는 제외하고 나머지를
	 * 모두 다 메인메소드가 있는 Ex라는 클래스에 때려박았다
	 * 
	 * 이렇게 되었기 때문에 우리가 프로그램 로직을 바꾸거나 UI를 바꾸기 위해서는
	 * Ex의 내용을 모두 바꿨어야 한다!
	 * 
	 * 만약 단일책임원칙이 제대로 지켜진 프로그램이라면
	 * 우리가 무언가 수정할 사항이 있다면 해당하는 클래스들만 수정을 가해주면 된다
	 * 
	 * 이런 단일책임원칙을 지키기 위한 디자인 패턴 중 가장 유명한게 바로
	 * MVC패턴이란 것이다
	 * 
	 * MVC패런이란 클래스의 종류를 3개로 나누어서
	 * 따로따로 각각의 클래스가 한가지 책임을 지도록 만드는 패턴이다
	 * 
	 * M:Model
	 * 	모델이란, 해당 프로그램에서 사용할 데이터의 틀을 규정해놓은 클래스이다.
	 * 	필드, 겟터/셋터, equals(), toString()정도의 메소드만 들어가는 아주 간단한 형태의 클래스이며
	 * 	필드의 경우 만약 데이터베이스가 있을 경우 테이블과 똑같이 맞춰준다
	 * 	예를 들어 테이블에 있는 컬럼이 int id, String name 등등의 컬럼이 있으면
	 * (테이블에  int id, String name 과 같은 컬럼이 있으면?)
	 *  똑같이 만들어주면 된다
	 *  이름에는 항상 DTO(Date Transfer Object)나 VO(Value Object)가 들어간다
	 *  DTO: 데이터의 교환을 위해 생성되는 객체
	 *  (뷰가 보내준 데이터를 담아서 DB에 전달하거나 DB의 데이터를 담아서 뷰에 전달하는 클래스에 뒤에 DTO라 붙여주고)
	 *  VO: DTO와 동일하지만 읽기만 가능한 객체, 변경이 불가능
	 *  (DB의 데이터를 담아서 뷰에 전달하는 클래스면 VO라고 부르지만)
	 *  (딱히 그러한 패턴을 꼭 따라가진 않고 이제는 DTO VO를 자유롭게 쓰는 편입니다)
	 *  (다만 한개의 프로젝트에선 모델이면 모두 DTO로 통일하거나 VO로 통일하는 편입니다.)
	 * V:View
	 * 	뷰란, 사용자가 실제로 보게되는 화면을 말한다
	 *  여러분들이 만약 웹 프로그래밍을 하게 된다면 뷰는 웹 브라우저에서 뜨는 HTML 또는 JSP가 된다
	 *  여러분들이 모바일 프로그래밍을 하게 된다면 안드로이드 혹은 iOS에서 출력되는 화면이 뷰가 된다.
	 * C:Controller
	 * 	컨트롤러는 뷰에서 사용자가 요청한 정보를 모델에 담아서 다시 뷰로 보내주는 일종의 중간다리 역할을 하는 클래스이다.
	 *  예를 들어, 게시판 목록 보기를 사용자가 선택하면 컨트롤러가 해당하는 정보를 ArrayList에 담아서
	 *  다시 뷰로 보내주는 역할을 하게 된다.
	 *  
	 * 따라서 MVC패턴은 다음과 같은 흐름도를 가지게 된다
	 * 뷰에서 요청(사용자의 요청) -> 컨트롤러가 해당 요청에 맞추어 데이터를 가공 후 다시 결과를 뷰로 보냄
	 * 이렇게 분업이 되어있기 때문에 만약 UI를 수정하면 뷰를 수정하기만 하면 되고, 
	 * 데이터 가공을 고쳐야 한다면 컨트롤러쪽만 고쳐주면 된다 
	 * 
	 * 
	 * 뷰에서 사용자가 로그인 요청을 한다 => 컨트롤러가 해당 요청을 UserDTO의 담긴 형태로 받아서 결과를 연산한다
	 */	
}
